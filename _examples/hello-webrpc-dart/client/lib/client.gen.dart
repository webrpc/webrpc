import 'dart:async';
import 'dart:convert';

import 'package:meta/meta.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

import 'package:http/http.dart' as http;

part 'client.gen.freezed.dart';
part 'client.gen.g.dart';

// hello-webrpc v1.0.0 5ace0c3aa305e464d6a2c180f43e8876be34e155
// --
// This file has been generated by https://github.com/webrpc/webrpc using gen/dart
// Do not edit by hand. Update your webrpc schema and re-generate.

// WebRPC description and code-gen version
String webRPCVersion() {
  return "v1";
}

// Schema version of your RIDL schema
String WebRPCSchemaVersion() {
  return "v1.0.0";
}

// Schema hash generated from your RIDL schema
String WebRPCSchemaHash() {
  return "5ace0c3aa305e464d6a2c180f43e8876be34e155";
}

// **********************************************************************
// MESSAGE TYPES.
// **********************************************************************
@freezed
abstract class Kind with _$Kind {
  const factory Kind.user() = USER;
  const factory Kind.admin() = ADMIN;
  factory Kind.fromJson(Map<String, dynamic> json) => _$KindFromJson(json);
}

@freezed
abstract class User with _$User {
  @JsonSerializable(explicitToJson: true)
  factory User({
    @JsonKey(name: 'id') @required int ID,
    @JsonKey(name: 'USERNAME') @required String username,
    @required Kind role,
    @required Map<String, dynamic> meta,
    @required int internalID,
    @JsonKey(name: 'created_at') DateTime createdAt,
  }) = _User;
  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
}

@freezed
abstract class Page with _$Page {
  @JsonSerializable(explicitToJson: true)
  factory Page({
    @required int num,
  }) = _Page;
  factory Page.fromJson(Map<String, dynamic> json) => _$PageFromJson(json);
}

// *********************************************************************
// ExampleService METHOD ARGUMENT TYPES.
// *********************************************************************
@freezed
abstract class _GetUserArgs with _$_GetUserArgs {
  @JsonSerializable(explicitToJson: true)
  factory _GetUserArgs({
    @required int userID,
  }) = _GetUserArgs_Freezed;
  factory _GetUserArgs.fromJson(Map<String, dynamic> json) =>
      _$_GetUserArgsFromJson(json);
}

@freezed
abstract class _FindUsersArgs with _$_FindUsersArgs {
  @JsonSerializable(explicitToJson: true)
  factory _FindUsersArgs({
    @required String q,
  }) = _FindUsersArgs_Freezed;
  factory _FindUsersArgs.fromJson(Map<String, dynamic> json) =>
      _$_FindUsersArgsFromJson(json);
}

// *********************************************************************
// ExampleService METHOD RETURN TYPES.
// *********************************************************************

@freezed
abstract class PingResult with _$PingResult {
  @JsonSerializable(explicitToJson: true)
  factory PingResult({
    @required bool status,
  }) = _PingResult;
  factory PingResult.fromJson(Map<String, dynamic> json) =>
      _$PingResultFromJson(json);
}

@freezed
abstract class GetUserResult with _$GetUserResult {
  @JsonSerializable(explicitToJson: true)
  factory GetUserResult({
    @required User user,
  }) = _GetUserResult;
  factory GetUserResult.fromJson(Map<String, dynamic> json) =>
      _$GetUserResultFromJson(json);
}

@freezed
abstract class FindUsersResult with _$FindUsersResult {
  @JsonSerializable(explicitToJson: true)
  factory FindUsersResult({
    @required Page page,
    @required List<User> users,
  }) = _FindUsersResult;
  factory FindUsersResult.fromJson(Map<String, dynamic> json) =>
      _$FindUsersResultFromJson(json);
}

// *********************************************************************
// Service Interfaces. Useful for testing purposes.
// *********************************************************************

abstract class ExampleService {
  Stream<RpcState<PingResult>> ping({
    Map<String, String> headers,
  });

  Stream<RpcState<GetUserResult>> getUser({
    @required int userID,
    Map<String, String> headers,
  });

  Stream<RpcState<FindUsersResult>> findUsers({
    @required String q,
    Map<String, String> headers,
  });
}

// *********************************************************************
// RpcResponse TYPE.
// *********************************************************************

// This class provides type safe access to the state of an Rpc Request
// and it's Response data. Can be used easily with Bloc. For more info See https://www.azavea.com/blog/2019/12/12/modeling-state-with-typescript/
// See https://pub.dev/packages/freezed to learn how to use this type.
@freezed
abstract class RpcState<T> with _$RpcState<T> {
  // initial state prior to any request being made.
  const factory RpcState.idle() = _RpcStateIdle<T>;
  // request has been made and awaiting a response.
  const factory RpcState.loading() = _RpcStateLoading<T>;
  // request made and returned successfully with data.
  const factory RpcState.ok({
    @required T data,
  }) = _RpcStateOk<T>;
  // request made and returned successfully without data.
  const factory RpcState.unit() = _RpcStateUnit<T>;
  // request returned an error with a message and status code.
  // The optional stackTrace is useful for debugging exceptions
  // thrown in Rpc client methods.
  const factory RpcState.err({
    @required String reason,
    @required int statusCode,
    String stackTrace,
  }) = _RpcStateErr<T>;
}
// ***********************************************************************
// WEBRPC-DART SERVICE CLIENTS.
// ***********************************************************************

class ExampleServiceRpc implements ExampleService {
  final String host;
  final String _srvcPath;
  ExampleServiceRpc({
    @required this.host,
  }) : _srvcPath = '${_removeSlash(host)}/rpc/ExampleService';

  Future<http.Response> _makeRequest(
    String route, {
    dynamic json = "{}",
    Map<String, String> headers,
  }) {
    return http.post(
      '$_srvcPath/$route',
      headers: {
        ...?headers,
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: jsonEncode(json),
    );
  }

  _RpcErr _getErr(http.Response r) {
    try {
      return _RpcErr.fromJson(jsonDecode(r.body));
    } on Exception catch (_) {
      return _RpcErr.unknown;
    }
  }

  @override
  Stream<RpcState<PingResult>> ping({
    Map<String, String> headers,
  }) async* {
    yield const RpcState.loading();
    try {
      final http.Response response = await _makeRequest(
        'Ping',
        headers: headers,
      );

      if (!_nonErrorcodes.contains(response.statusCode)) {
        final _RpcErr err = _getErr(response);
        yield RpcState.err(
          reason: err.message,
          statusCode: err.httpErr.code,
        );
      } else {
        yield RpcState.ok(
          data: PingResult.fromJson(
            jsonDecode(
              response.body,
            ),
          ),
        );
      }
    } on Exception catch (e, stackTrace) {
      yield RpcState.err(
        statusCode: 400,
        reason: e.toString(),
        stackTrace: stackTrace.toString(),
      );
    }
  }

  @override
  Stream<RpcState<GetUserResult>> getUser({
    @required int userID,
    Map<String, String> headers,
  }) async* {
    yield const RpcState.loading();
    try {
      final _GetUserArgs args = _GetUserArgs(
        userID: userID,
      );

      final http.Response response = await _makeRequest(
        'GetUser',
        json: args.toJson(),
        headers: headers,
      );

      if (!_nonErrorcodes.contains(response.statusCode)) {
        final _RpcErr err = _getErr(response);
        yield RpcState.err(
          reason: err.message,
          statusCode: err.httpErr.code,
        );
      } else {
        yield RpcState.ok(
          data: GetUserResult.fromJson(
            jsonDecode(
              response.body,
            ),
          ),
        );
      }
    } on Exception catch (e, stackTrace) {
      yield RpcState.err(
        statusCode: 400,
        reason: e.toString(),
        stackTrace: stackTrace.toString(),
      );
    }
  }

  @override
  Stream<RpcState<FindUsersResult>> findUsers({
    @required String q,
    Map<String, String> headers,
  }) async* {
    yield const RpcState.loading();
    try {
      final _FindUsersArgs args = _FindUsersArgs(
        q: q,
      );

      // ignore: omit_local_variable_types
      final http.Response response = await _makeRequest(
        'FindUsers',
        json: args.toJson(),
        headers: headers,
      );

      if (!_nonErrorcodes.contains(response.statusCode)) {
        final _RpcErr err = _getErr(response);
        yield RpcState.err(
          reason: err.message,
          statusCode: err.httpErr.code,
        );
      } else {
        yield RpcState.ok(
          data: FindUsersResult.fromJson(
            jsonDecode(
              response.body,
            ),
          ),
        );
      }
    } on Exception catch (e, stackTrace) {
      yield RpcState.err(
        statusCode: 400,
        reason: e.toString(),
        stackTrace: stackTrace.toString(),
      );
    }
  }
}

// *********************************************************************
// WEBRPC-DART HELPER CODE.
// *********************************************************************

String _removeSlash(String host) => host.endsWith('/')
    ? host.replaceRange(host.length - 1, host.length, '')
    : host;

const Set<int> _nonErrorcodes = {
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  300,
  301,
  302,
  303,
  304,
  307,
  308,
};

// An http error.
class _HttpErr {
  final String status;
  final int code;
  const _HttpErr(this.status, this.code);

  Map<String, dynamic> toMap() => {'status': status, 'code': code};
  String toJson() => jsonEncode(toMap());
  static _HttpErr fromMap(Map<String, dynamic> map) =>
      _HttpErr(map['status'] as String, map['code'] as int);

  static _HttpErr fromJson(dynamic json) => fromMap(
        jsonDecode(json),
      );
}

// An error created by the rpc server.
class _RpcErr {
  final String message;
  final String path;
  final DateTime time;
  final _HttpErr httpErr;
  const _RpcErr({this.message, this.path, this.httpErr, this.time});
  static const _RpcErr unknown = _RpcErr(
      message: 'an unknown error has occured',
      path: 'unknown',
      httpErr: _HttpErr('unknown', 400),
      time: null);
  Map<String, dynamic> toMap() => {
        'message': message,
        'path': path,
        'httpErr': httpErr.toMap(),
        'time-stamp': time.toString()
      };
  String toJson() => jsonEncode(toMap());
  static _RpcErr fromMap(Map<String, dynamic> map) => _RpcErr(
        message: map['message'] as String,
        path: map['path'] as String,
        time: DateTime.parse(
          map['time-stamp'],
        ),
        httpErr: _HttpErr.fromMap(
          map['httpErr'],
        ),
      );
  static _RpcErr fromJson(dynamic json) => fromMap(
        jsonDecode(json),
      );
}
