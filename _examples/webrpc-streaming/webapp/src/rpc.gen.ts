/* eslint-disable */
// webrpc-sse-chat v1.0.0 e2216792ea031e9bc24bbfd40d224b0a84f5c1c5
// --
// Code generated by Webrpc-gen@v0.29.0-16-g28d4195 with ../../../gen-typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=proto/chat.ridl -target=../../../gen-typescript -client -out=webapp/src/rpc.gen.ts

// Webrpc description and code-gen version
export const WebrpcVersion = "v1"

// Schema version of your RIDL schema
export const WebrpcSchemaVersion = "v1.0.0"

// Schema hash generated from your RIDL schema
export const WebrpcSchemaHash = "e2216792ea031e9bc24bbfd40d224b0a84f5c1c5"

//
// Client interface
//

export interface ChatClient {
  sendMessage(req: SendMessageRequest, headers?: object, signal?: AbortSignal): Promise<SendMessageResponse>

  subscribeMessages(req: SubscribeMessagesRequest, options: WebrpcStreamOptions<SubscribeMessagesResponse>): WebrpcStreamController
}


//
// Schema types
//

export interface Message {
  id: number
  username: string
  text: string
  createdAt: string
}

export interface SendMessageRequest {
  username: string
  text: string
}

export interface SendMessageResponse {
}

export interface SubscribeMessagesRequest {
  username: string
  lastMessageId?: number
}

export interface SubscribeMessagesResponse {
  message: Message
}



//
// Client
//

export class Chat implements ChatClient {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/Chat/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, '')
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  queryKey = {
    sendMessage: (req: SendMessageRequest) => ['Chat', 'sendMessage', req] as const,
    subscribeMessages: (req: SubscribeMessagesRequest) => ['Chat', 'subscribeMessages', req] as const,
  }

  sendMessage = (req: SendMessageRequest, headers?: object, signal?: AbortSignal): Promise<SendMessageResponse> => {
    return this.fetch(
      this.url('SendMessage'),
      createHttpRequest(JsonEncode(req, 'SendMessageRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<SendMessageResponse>(_data, 'SendMessageResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  subscribeMessages = (req: SubscribeMessagesRequest, options: WebrpcStreamOptions<SubscribeMessagesResponse>): WebrpcStreamController => {
    const abortController = new AbortController()
    const abortSignal = abortController.signal

    if (options.signal) {
      abortSignal.addEventListener("abort", () => abortController.abort(options.signal?.reason), {
        signal: options.signal,
      })
    }

    const _fetch = () => this.fetch(this.url('SubscribeMessages'),
      createHttpRequest(JsonEncode(req, 'SubscribeMessagesRequest'), options.headers, abortSignal)
    ).then(async (res) => {
      await sseResponse(res, options, _fetch)
    }, (error) => {
      options.onError(error, _fetch)
    })

    const resp = _fetch()
    return {
      abort: abortController.abort.bind(abortController),
      closed: resp
    }
  }
}
  
const sseResponse = async (
    res: Response,
    options: WebrpcStreamOptions<any>,
    retryFetch: () => Promise<void>
) => {
    const {onMessage, onOpen, onClose, onError} = options;

    if (!res.ok) {
        try {
            await buildResponse(res)
        } catch (error) {
            // @ts-ignore
            onError(error, retryFetch)
        }
        return;
    }

    if (!res.body) {
        onError(
            WebrpcBadResponseError.new({
                status: res.status,
                cause: "Invalid response, missing body",
            }),
            retryFetch
        )
        return;
    }

    onOpen && onOpen()

    const reader = res.body.getReader()
    const decoder = new TextDecoder()
    let buffer = "";
    let lastReadTime = Date.now()
    const timeout = (10 + 1) * 1000;
    let timeoutError = false
    const intervalId = setInterval(() => {
        if (Date.now() - lastReadTime > timeout) {
          timeoutError = true
          clearInterval(intervalId)
          reader.releaseLock()
        }
    }, timeout)

    while (true) {
        let value;
        let done;
        try {
            ({value, done} = await reader.read())
            if (timeoutError) throw new Error("Timeout, no data or heartbeat received")
            lastReadTime = Date.now()
            buffer += decoder.decode(value, {stream: true})
        } catch (error) {
            if (error instanceof DOMException && error.name === "AbortError") {
                onError(
                    WebrpcClientAbortedError.new({
                        message: "AbortError",
                        cause: `AbortError: ${error.message}`,
                    }),
                    () => {
                        throw new Error("Abort signal cannot be used to reconnect")
                    }
                )
            } else {
                onError(
                    WebrpcStreamLostError.new({
                        cause: `reader.read(): ${error instanceof Error ? error.message : String(error)}`,
                    }),
                    retryFetch
                )
            }
            return;
        }

        let lines = buffer.split("\n")
        for (let i = 0; i < lines.length - 1; i++) {
            const line = lines[i];
            if (line?.length === 0) {
                continue;
            }
            let data: any;
            try {
                data = JSON.parse(line)
                if (data.hasOwnProperty("webrpcError")) {
                    const error = data.webrpcError;
                    const code: number =
                        typeof error.code === "number" ? error.code : 0;
                    onError(
                        (webrpcErrorByCode[code] || WebrpcError).new(error),
                        retryFetch
                    )
                    return;
                }
            } catch (error) {
                if (
                    error instanceof Error &&
                    error.message === "Abort signal cannot be used to reconnect"
                ) {
                    throw error;
                }
                onError(
                    WebrpcBadResponseError.new({
                        status: res.status,
                        cause: `JSON.parse(): ${error instanceof Error ? error.message : String(error)}`,
                    }),
                    retryFetch
                )
            }
            onMessage(data)
        }

        if (!done) {
            const lastLine = lines[lines.length - 1];
            buffer = lastLine || "";
            continue;
        }

        onClose && onClose()
        return;
    }
};



const createHttpRequest = (body: string = '{}', headers: object = {}, signal: AbortSignal | null = null): object => {
  const reqHeaders: { [key: string]: string } = { ...headers, 'Content-Type': 'application/json' }
  return { method: 'POST', headers: reqHeaders, body, signal }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch(error) {
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${error instanceof Error ? error.message : String(error)}: response text: ${text}`},
      )
    }
    if (!res.ok) {
      const code: number = (typeof data.code === 'number') ? data.code : 0
      throw (webrpcErrorByCode[code] || WebrpcError).new(data)
    }
    return data
  })
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>


export interface WebrpcStreamOptions<T> extends WebrpcOptions {
  onMessage: (message: T) => void;
  onError: (error: WebrpcError, reconnect: () => void) => void;
  onOpen?: () => void;
  onClose?: () => void;
}

export interface WebrpcOptions {
  headers?: HeadersInit;
  signal?: AbortSignal;
}

export interface WebrpcStreamController {
  abort: (reason?: any) => void;
  closed: Promise<void>;
}





export const JsonEncode = <T = any>(obj: T, _typ: string = ''): string => {
  return JSON.stringify(obj)
}

export const JsonDecode = <T = any>(data: string | any, _typ: string = ''): T => {
  let parsed: any = data
  if (typeof data === 'string') {
    try { parsed = JSON.parse(data) } catch (err) {
      throw WebrpcBadResponseError.new({ cause: `JsonDecode: JSON.parse failed: ${(err as Error).message}` })
    }
  }
  return parsed as T
}


//
// Errors
//

type WebrpcErrorParams = { name?: string, code?: number, message?: string, status?: number, cause?: string }

export class WebrpcError extends Error {
  code: number
  status: number

  constructor(error: WebrpcErrorParams = {}) {
    super(error.message)
    this.name = error.name || 'WebrpcEndpointError'
    this.code = typeof error.code === 'number' ? error.code : 0
    this.message = error.message || `endpoint error`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcError.prototype)
  }

  static new(payload: any): WebrpcError {
    return new this({ message: payload.message, code: payload.code, status: payload.status, cause: payload.cause })
  }
}


export class WebrpcEndpointError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcEndpoint'
    this.code = typeof error.code === 'number' ? error.code : 0
    this.message = error.message || `endpoint error`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)
  }
}

export class WebrpcRequestFailedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcRequestFailed'
    this.code = typeof error.code === 'number' ? error.code : -1
    this.message = error.message || `request failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)
  }
}

export class WebrpcBadRouteError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadRoute'
    this.code = typeof error.code === 'number' ? error.code : -2
    this.message = error.message || `bad route`
    this.status = typeof error.status === 'number' ? error.status : 404
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)
  }
}

export class WebrpcBadMethodError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadMethod'
    this.code = typeof error.code === 'number' ? error.code : -3
    this.message = error.message || `bad method`
    this.status = typeof error.status === 'number' ? error.status : 405
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)
  }
}

export class WebrpcBadRequestError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadRequest'
    this.code = typeof error.code === 'number' ? error.code : -4
    this.message = error.message || `bad request`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)
  }
}

export class WebrpcBadResponseError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadResponse'
    this.code = typeof error.code === 'number' ? error.code : -5
    this.message = error.message || `bad response`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)
  }
}

export class WebrpcServerPanicError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcServerPanic'
    this.code = typeof error.code === 'number' ? error.code : -6
    this.message = error.message || `server panic`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)
  }
}

export class WebrpcInternalErrorError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcInternalError'
    this.code = typeof error.code === 'number' ? error.code : -7
    this.message = error.message || `internal error`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)
  }
}

export class WebrpcClientAbortedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcClientAborted'
    this.code = typeof error.code === 'number' ? error.code : -8
    this.message = error.message || `request aborted by client`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcClientAbortedError.prototype)
  }
}

export class WebrpcStreamLostError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcStreamLost'
    this.code = typeof error.code === 'number' ? error.code : -9
    this.message = error.message || `stream lost`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype)
  }
}

export class WebrpcStreamFinishedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcStreamFinished'
    this.code = typeof error.code === 'number' ? error.code : -10
    this.message = error.message || `stream finished`
    this.status = typeof error.status === 'number' ? error.status : 200
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype)
  }
}


//
// Schema errors
//

export class EmptyUsernameError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'EmptyUsername'
    this.code = typeof error.code === 'number' ? error.code : 100
    this.message = error.message || `Username must be provided.`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, EmptyUsernameError.prototype)
  }
}


export enum errors {
  WebrpcEndpoint = 'WebrpcEndpoint',
  WebrpcRequestFailed = 'WebrpcRequestFailed',
  WebrpcBadRoute = 'WebrpcBadRoute',
  WebrpcBadMethod = 'WebrpcBadMethod',
  WebrpcBadRequest = 'WebrpcBadRequest',
  WebrpcBadResponse = 'WebrpcBadResponse',
  WebrpcServerPanic = 'WebrpcServerPanic',
  WebrpcInternalError = 'WebrpcInternalError',
  WebrpcClientAborted = 'WebrpcClientAborted',
  WebrpcStreamLost = 'WebrpcStreamLost',
  WebrpcStreamFinished = 'WebrpcStreamFinished',
  EmptyUsername = 'EmptyUsername',
}

export enum WebrpcErrorCodes {
  WebrpcEndpoint = 0,
  WebrpcRequestFailed = -1,
  WebrpcBadRoute = -2,
  WebrpcBadMethod = -3,
  WebrpcBadRequest = -4,
  WebrpcBadResponse = -5,
  WebrpcServerPanic = -6,
  WebrpcInternalError = -7,
  WebrpcClientAborted = -8,
  WebrpcStreamLost = -9,
  WebrpcStreamFinished = -10,
  EmptyUsername = 100,
}

export const webrpcErrorByCode: { [code: number]: any } = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [-8]: WebrpcClientAbortedError,
  [-9]: WebrpcStreamLostError,
  [-10]: WebrpcStreamFinishedError,
  [100]: EmptyUsernameError,
}



//
// Webrpc
//

export const WebrpcHeader = "Webrpc"

export const WebrpcHeaderValue = "webrpc@v0.29.0-16-g28d4195;gen-typescript@unknown;webrpc-sse-chat@v1.0.0"

type WebrpcGenVersions = {
  WebrpcGenVersion: string;
  codeGenName: string;
  codeGenVersion: string;
  schemaName: string;
  schemaVersion: string;
};

export function VersionFromHeader(headers: Headers): WebrpcGenVersions {
  const headerValue = headers.get(WebrpcHeader)
  if (!headerValue) {
    return {
      WebrpcGenVersion: "",
      codeGenName: "",
      codeGenVersion: "",
      schemaName: "",
      schemaVersion: "",
    };
  }

  return parseWebrpcGenVersions(headerValue)
}

function parseWebrpcGenVersions(header: string): WebrpcGenVersions {
  const versions = header.split(";")
  if (versions.length < 3) {
    return {
      WebrpcGenVersion: "",
      codeGenName: "",
      codeGenVersion: "",
      schemaName: "",
      schemaVersion: "",
    };
  }

  const [_, WebrpcGenVersion] = versions[0]!.split("@")
  const [codeGenName, codeGenVersion] = versions[1]!.split("@")
  const [schemaName, schemaVersion] = versions[2]!.split("@")

  return {
    WebrpcGenVersion: WebrpcGenVersion ?? "",
    codeGenName: codeGenName ?? "",
    codeGenVersion: codeGenVersion ?? "",
    schemaName: schemaName ?? "",
    schemaVersion: schemaVersion ?? "",
  };
}

