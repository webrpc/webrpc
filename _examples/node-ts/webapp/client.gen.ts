/* eslint-disable */
// node-ts v1.0.0 515ff49343e8b920307b565a0eae78b79b8ea1bd
// --
// Code generated by Webrpc-gen with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=service.ridl -target=typescript -client -out=./webapp/client.gen.ts

// Webrpc description and code-gen version
export const WebrpcVersion = "v1"

// Schema version of your RIDL schema
export const WebrpcSchemaVersion = "v1.0.0"

// Schema hash generated from your RIDL schema
export const WebrpcSchemaHash = "515ff49343e8b920307b565a0eae78b79b8ea1bd"

//
// Client interface
//

export interface ExampleClient {
  /**
   * @deprecated Use /health endpoint instead.
   */
  ping(req: PingRequest, headers?: object, signal?: AbortSignal): Promise<PingResponse>

  /**
   * GetUser returns a user by ID.
   */
  getUser(req: GetUserRequest, headers?: object, signal?: AbortSignal): Promise<GetUserResponse>

  /**
   * Get article by id.
   */
  getArticle(req: GetArticleRequest, headers?: object, signal?: AbortSignal): Promise<GetArticleResponse>
}


//
// Schema types
//

export enum Kind {
  USER = 'USER',
  ADMIN = 'ADMIN'
}

export interface User {
  id: number
  USERNAME: string
  role: Kind
  meta: {[key: string]: any}
  balance: bigint
  createdAt?: string
  extra: Extra
}

export interface Extra {
  info: string
  amount: bigint
  points: Array<bigint>
}

export interface Page {
  num: number
}

export interface GetArticleRequest {
  articleId: number
  byBN: bigint
}

export interface GetArticleResponse {
  title: string
  content?: string
  largeNum: bigint
}

export interface PingRequest {
  counter?: bigint
}

export interface PingResponse {
}

export interface GetUserRequest {
  userId: number
}

export interface GetUserResponse {
  code: number
  user: User
}




//
// Client
//

export class Example implements ExampleClient {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/Example/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname.replace(/\/*$/, '')
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  queryKey = {
    ping: (req: PingRequest) => ['Example', 'ping', req] as const,
    getUser: (req: GetUserRequest) => ['Example', 'getUser', req] as const,
    getArticle: (req: GetArticleRequest) => ['Example', 'getArticle', req] as const,
  }

  ping = (req: PingRequest, headers?: object, signal?: AbortSignal): Promise<PingResponse> => {
    return this.fetch(
      this.url('Ping'),
      createHttpRequest(JsonEncode(req, 'PingRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<PingResponse>(_data, 'PingResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getUser = (req: GetUserRequest, headers?: object, signal?: AbortSignal): Promise<GetUserResponse> => {
    return this.fetch(
      this.url('GetUser'),
      createHttpRequest(JsonEncode(req, 'GetUserRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetUserResponse>(_data, 'GetUserResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

  getArticle = (req: GetArticleRequest, headers?: object, signal?: AbortSignal): Promise<GetArticleResponse> => {
    return this.fetch(
      this.url('GetArticle'),
      createHttpRequest(JsonEncode(req, 'GetArticleRequest'), headers, signal)).then((res) => {
      return buildResponse(res).then(_data => {
        return JsonDecode<GetArticleResponse>(_data, 'GetArticleResponse')
      })
    }, (error) => {
      throw WebrpcRequestFailedError.new({ cause: `fetch(): ${error instanceof Error ? error.message : String(error)}` })
    })
  }

}

const createHttpRequest = (body: string = '{}', headers: object = {}, signal: AbortSignal | null = null): object => {
  const reqHeaders: { [key: string]: string } = { ...headers, 'Content-Type': 'application/json' }
  return { method: 'POST', headers: reqHeaders, body, signal }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch(error) {
      throw WebrpcBadResponseError.new({
        status: res.status,
        cause: `JSON.parse(): ${error instanceof Error ? error.message : String(error)}: response text: ${text}`},
      )
    }
    if (!res.ok) {
      const code: number = (typeof data.code === 'number') ? data.code : 0
      throw (webrpcErrorByCode[code] || WebrpcError).new(data)
    }
    return data
  })
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>





//
// BigInt helpers
//

const BIG_INT_FIELDS: { [typ: string]: (string | [string, string])[] } = {
  Extra: ['amount', 'points[]'],
  GetArticleRequest: ['byBN'],
  GetArticleResponse: ['largeNum'],
  GetUserResponse: [['user', 'User']],
  PingRequest: ['counter'],
  User: ['balance', ['extra', 'Extra']]
}

// Encode in-place: mutate provided object graph to serialize bigints to strings.
function encodeType(typ: string, obj: any): any {
  if (obj == null || typeof obj !== 'object') return obj
  const descs = BIG_INT_FIELDS[typ] || []
  if (!descs.length) return obj
  for (const d of descs) {
    if (Array.isArray(d)) {
      const [fieldName, nestedType] = d
      if (fieldName.endsWith('[]')) {
        const base = fieldName.slice(0, -2)
        const arr = obj[base]
        if (Array.isArray(arr)) {
          for (let i = 0; i < arr.length; i++) arr[i] = encodeType(nestedType, arr[i])
        }
      } else if (obj[fieldName]) {
        obj[fieldName] = encodeType(nestedType, obj[fieldName])
      }
      continue
    }
    if (d.endsWith('[]')) {
      const base = d.slice(0, -2)
      const arr = obj[base]
      if (Array.isArray(arr)) {
        for (let i = 0; i < arr.length; i++) {
          if (typeof arr[i] === 'bigint') arr[i] = arr[i].toString()
        }
      }
      continue
    }
    if (typeof obj[d] === 'bigint') obj[d] = obj[d].toString()
  }
  return obj
}

// Decode in-place: mutate object graph; throw if expected numeric string is invalid.
function decodeType(typ: string, obj: any): any {
  if (obj == null || typeof obj !== 'object') return obj
  const descs = BIG_INT_FIELDS[typ] || []
  if (!descs.length) return obj
  for (const d of descs) {
    if (Array.isArray(d)) {
      const [fieldName, nestedType] = d
      if (fieldName.endsWith('[]')) {
        const base = fieldName.slice(0, -2)
        const arr = obj[base]
        if (Array.isArray(arr)) {
          for (let i = 0; i < arr.length; i++) arr[i] = decodeType(nestedType, arr[i])
        }
      } else if (obj[fieldName]) {
        obj[fieldName] = decodeType(nestedType, obj[fieldName])
      }
      continue
    }
    if (d.endsWith('[]')) {
      const base = d.slice(0, -2)
      const arr = obj[base]
      if (Array.isArray(arr)) {
        for (let i = 0; i < arr.length; i++) {
          const v = arr[i]
          if (typeof v === 'string') {
            try { arr[i] = BigInt(v) } catch (e) { throw WebrpcBadResponseError.new({ cause: `Invalid bigint value for ${base}[${i}]: ${v}` }) }
          }
        }
      }
      continue
    }
    const v = obj[d]
    if (typeof v === 'string') {
      try { obj[d] = BigInt(v) } catch (e) { throw WebrpcBadResponseError.new({ cause: `Invalid bigint value for ${d}: ${v}` }) }
    }
  }
  return obj
}

// Encode object of given root type to JSON with BigInts converted to decimal strings.
export const JsonEncode = <T = any>(obj: T, typ: string = ''): string => {
  return JSON.stringify(encodeType(typ, obj))
}

// Decode data (JSON string or already-parsed object) and convert declared BigInt string fields back to BigInt.
export const JsonDecode = <T = any>(data: string | any, typ: string = ''): T => {
  let parsed: any = data
  if (typeof data === 'string') {
    try { parsed = JSON.parse(data) } catch (err) {
      throw WebrpcBadResponseError.new({ cause: `JsonDecode: JSON.parse failed: ${(err as Error).message}` })
    }
  }
  return decodeType(typ, parsed) as T
}


//
// Errors
//

type WebrpcErrorParams = { name?: string, code?: number, message?: string, status?: number, cause?: string }

export class WebrpcError extends Error {
  code: number
  status: number

  constructor(error: WebrpcErrorParams = {}) {
    super(error.message)
    this.name = error.name || 'WebrpcEndpointError'
    this.code = typeof error.code === 'number' ? error.code : 0
    this.message = error.message || `endpoint error`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcError.prototype)
  }

  static new(payload: any): WebrpcError {
    return new this({ message: payload.message, code: payload.code, status: payload.status, cause: payload.cause })
  }
}


export class WebrpcEndpointError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcEndpoint'
    this.code = typeof error.code === 'number' ? error.code : 0
    this.message = error.message || `endpoint error`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcEndpointError.prototype)
  }
}

export class WebrpcRequestFailedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcRequestFailed'
    this.code = typeof error.code === 'number' ? error.code : -1
    this.message = error.message || `request failed`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcRequestFailedError.prototype)
  }
}

export class WebrpcBadRouteError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadRoute'
    this.code = typeof error.code === 'number' ? error.code : -2
    this.message = error.message || `bad route`
    this.status = typeof error.status === 'number' ? error.status : 404
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadRouteError.prototype)
  }
}

export class WebrpcBadMethodError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadMethod'
    this.code = typeof error.code === 'number' ? error.code : -3
    this.message = error.message || `bad method`
    this.status = typeof error.status === 'number' ? error.status : 405
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadMethodError.prototype)
  }
}

export class WebrpcBadRequestError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadRequest'
    this.code = typeof error.code === 'number' ? error.code : -4
    this.message = error.message || `bad request`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadRequestError.prototype)
  }
}

export class WebrpcBadResponseError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcBadResponse'
    this.code = typeof error.code === 'number' ? error.code : -5
    this.message = error.message || `bad response`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcBadResponseError.prototype)
  }
}

export class WebrpcServerPanicError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcServerPanic'
    this.code = typeof error.code === 'number' ? error.code : -6
    this.message = error.message || `server panic`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcServerPanicError.prototype)
  }
}

export class WebrpcInternalErrorError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcInternalError'
    this.code = typeof error.code === 'number' ? error.code : -7
    this.message = error.message || `internal error`
    this.status = typeof error.status === 'number' ? error.status : 500
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcInternalErrorError.prototype)
  }
}

export class WebrpcClientAbortedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcClientAborted'
    this.code = typeof error.code === 'number' ? error.code : -8
    this.message = error.message || `request aborted by client`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcClientAbortedError.prototype)
  }
}

export class WebrpcStreamLostError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcStreamLost'
    this.code = typeof error.code === 'number' ? error.code : -9
    this.message = error.message || `stream lost`
    this.status = typeof error.status === 'number' ? error.status : 400
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcStreamLostError.prototype)
  }
}

export class WebrpcStreamFinishedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'WebrpcStreamFinished'
    this.code = typeof error.code === 'number' ? error.code : -10
    this.message = error.message || `stream finished`
    this.status = typeof error.status === 'number' ? error.status : 200
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, WebrpcStreamFinishedError.prototype)
  }
}


//
// Schema errors
//

export class UnauthorizedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Unauthorized'
    this.code = typeof error.code === 'number' ? error.code : 1000
    this.message = error.message || `Unauthorized access`
    this.status = typeof error.status === 'number' ? error.status : 401
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, UnauthorizedError.prototype)
  }
}

export class PermissionDeniedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'PermissionDenied'
    this.code = typeof error.code === 'number' ? error.code : 1001
    this.message = error.message || `Permission denied`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, PermissionDeniedError.prototype)
  }
}

export class SessionExpiredError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'SessionExpired'
    this.code = typeof error.code === 'number' ? error.code : 1002
    this.message = error.message || `Session expired`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, SessionExpiredError.prototype)
  }
}

export class GeoblockedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'Geoblocked'
    this.code = typeof error.code === 'number' ? error.code : 1003
    this.message = error.message || `Geoblocked region`
    this.status = typeof error.status === 'number' ? error.status : 451
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, GeoblockedError.prototype)
  }
}

export class RateLimitedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'RateLimited'
    this.code = typeof error.code === 'number' ? error.code : 1004
    this.message = error.message || `Rate-limited. Please slow down.`
    this.status = typeof error.status === 'number' ? error.status : 429
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, RateLimitedError.prototype)
  }
}

export class CorsDisallowedError extends WebrpcError {
  constructor(error: WebrpcErrorParams = {}) {
    super(error)
    this.name = error.name || 'CorsDisallowed'
    this.code = typeof error.code === 'number' ? error.code : 1005
    this.message = error.message || `CORS disallowed. JWT can't be used from a web app.`
    this.status = typeof error.status === 'number' ? error.status : 403
    if (error.cause !== undefined) this.cause = error.cause
    Object.setPrototypeOf(this, CorsDisallowedError.prototype)
  }
}


export enum errors {
  WebrpcEndpoint = 'WebrpcEndpoint',
  WebrpcRequestFailed = 'WebrpcRequestFailed',
  WebrpcBadRoute = 'WebrpcBadRoute',
  WebrpcBadMethod = 'WebrpcBadMethod',
  WebrpcBadRequest = 'WebrpcBadRequest',
  WebrpcBadResponse = 'WebrpcBadResponse',
  WebrpcServerPanic = 'WebrpcServerPanic',
  WebrpcInternalError = 'WebrpcInternalError',
  WebrpcClientAborted = 'WebrpcClientAborted',
  WebrpcStreamLost = 'WebrpcStreamLost',
  WebrpcStreamFinished = 'WebrpcStreamFinished',
  Unauthorized = 'Unauthorized',
  PermissionDenied = 'PermissionDenied',
  SessionExpired = 'SessionExpired',
  Geoblocked = 'Geoblocked',
  RateLimited = 'RateLimited',
  CorsDisallowed = 'CorsDisallowed',
}

export enum WebrpcErrorCodes {
  WebrpcEndpoint = 0,
  WebrpcRequestFailed = -1,
  WebrpcBadRoute = -2,
  WebrpcBadMethod = -3,
  WebrpcBadRequest = -4,
  WebrpcBadResponse = -5,
  WebrpcServerPanic = -6,
  WebrpcInternalError = -7,
  WebrpcClientAborted = -8,
  WebrpcStreamLost = -9,
  WebrpcStreamFinished = -10,
  Unauthorized = 1000,
  PermissionDenied = 1001,
  SessionExpired = 1002,
  Geoblocked = 1003,
  RateLimited = 1004,
  CorsDisallowed = 1005,
}

export const webrpcErrorByCode: { [code: number]: any } = {
  [0]: WebrpcEndpointError,
  [-1]: WebrpcRequestFailedError,
  [-2]: WebrpcBadRouteError,
  [-3]: WebrpcBadMethodError,
  [-4]: WebrpcBadRequestError,
  [-5]: WebrpcBadResponseError,
  [-6]: WebrpcServerPanicError,
  [-7]: WebrpcInternalErrorError,
  [-8]: WebrpcClientAbortedError,
  [-9]: WebrpcStreamLostError,
  [-10]: WebrpcStreamFinishedError,
  [1000]: UnauthorizedError,
  [1001]: PermissionDeniedError,
  [1002]: SessionExpiredError,
  [1003]: GeoblockedError,
  [1004]: RateLimitedError,
  [1005]: CorsDisallowedError,
}



//
// Webrpc
//

export const WebrpcHeader = "Webrpc"

export const WebrpcHeaderValue = "webrpc;gen-typescript@v0.21.1-0.20251023012506-d9bfc20078e1;node-ts@v1.0.0"

type WebrpcGenVersions = {
  WebrpcGenVersion: string;
  codeGenName: string;
  codeGenVersion: string;
  schemaName: string;
  schemaVersion: string;
};

export function VersionFromHeader(headers: Headers): WebrpcGenVersions {
  const headerValue = headers.get(WebrpcHeader)
  if (!headerValue) {
    return {
      WebrpcGenVersion: "",
      codeGenName: "",
      codeGenVersion: "",
      schemaName: "",
      schemaVersion: "",
    };
  }

  return parseWebrpcGenVersions(headerValue)
}

function parseWebrpcGenVersions(header: string): WebrpcGenVersions {
  const versions = header.split(";")
  if (versions.length < 3) {
    return {
      WebrpcGenVersion: "",
      codeGenName: "",
      codeGenVersion: "",
      schemaName: "",
      schemaVersion: "",
    };
  }

  const [_, WebrpcGenVersion] = versions[0]!.split("@")
  const [codeGenName, codeGenVersion] = versions[1]!.split("@")
  const [schemaName, schemaVersion] = versions[2]!.split("@")

  return {
    WebrpcGenVersion: WebrpcGenVersion ?? "",
    codeGenName: codeGenName ?? "",
    codeGenVersion: codeGenVersion ?? "",
    schemaName: schemaName ?? "",
    schemaVersion: schemaVersion ?? "",
  };
}

