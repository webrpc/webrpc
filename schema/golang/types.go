package golang

import (
	"go/types"
	"regexp"
	"strings"

	"github.com/pkg/errors"
	"github.com/webrpc/webrpc/schema"
)

// Given the `db:"id,omitempty,pk" json:"id,string"` struct tag,
// this regex will always return the following three submatches:
// [0]: json:"id,string"
// [1]: id
// [2]: ,string
var jsonTagRegex, _ = regexp.Compile(`\s?json:\"([^,\"]*)(,[^\"]*)?\"`)

func (p *parser) parseType(typ types.Type) (varType *schema.VarType, err error) {
	return p.parseNamedType("", typ)
}

func (p *parser) parseNamedType(typeName string, typ types.Type) (varType *schema.VarType, err error) {
	if cached, ok := p.parsedTypes[typ]; ok {
		return cached, nil
	}

	// We want to parse each unique type exactly once. Thus we store the result schema.VarType for
	// each input Go type into a hashmap cache. But also, since we need to support recursive types
	// (ie. self-referencing structs, linked lists, circular dependencies etc.), we warm the cache
	// up-front, and then we update the value via a pointer dereference in the defer function.
	// Any subseqential calls with the same input type, even nested/recursive calls from within this
	// function, will return the same pointer. Note: We're parsing sequentially, no need for sync.Map.
	lockRecursiveTypes := &schema.VarType{}
	p.parsedTypes[typ] = lockRecursiveTypes // Warm the cache up-front.
	defer func() {
		if err == nil {
			*lockRecursiveTypes = *varType // Update the value via a pointer dereference.
			// TODO: Return varType instead? They are the same, but we'd return the one pointer.
		}
	}()

	switch v := typ.(type) {
	case *types.Named:
		pkg := v.Obj().Pkg()
		typeName := v.Obj().Name()

		// Does the type satisfy encoding.TextMarshaller and encoding.TextUnmarshaler interfaces?
		// Then its value is always rendered as a quoted string in JSON encoding. Return string.
		marshalTextMethod, _, _ := types.LookupFieldOrMethod(v, true, pkg, "MarshalText")
		unmarshalTextMethod, _, _ := types.LookupFieldOrMethod(v, true, pkg, "UnmarshalText")
		if marshalTextMethod != nil && unmarshalTextMethod != nil &&
			strings.HasSuffix(marshalTextMethod.String(), ".MarshalText() ([]byte, error)") &&
			strings.HasSuffix(unmarshalTextMethod.String(), ".UnmarshalText(text []byte) error") {
			var varType schema.VarType
			if err := schema.ParseVarTypeExpr(p.schema, "string", &varType); err != nil {
				return nil, errors.Wrap(err, "failed to parse string")
			}
			return &varType, nil
		}

		if pkg != nil {
			// If the type belongs to a specific package, save the pkg reference to schema.Imports.
			// Prefix the type name with the package name to avoid conflicts.
			pkgPath := pkg.Path()

			// "command-line-arguments" is autogenerated by Go tool chain. Ignore.
			if pkgPath == "command-line-arguments" || pkgPath == p.schemaPkgName {
				pkgPath = ""
			}

			switch pkgPath + "." + typeName {
			case "time.Time":
				var varType schema.VarType
				if err := schema.ParseVarTypeExpr(p.schema, "timestamp", &varType); err != nil {
					return nil, errors.Wrap(err, "failed to parse timestamp")
				}
				return &varType, nil
			}

			typeName = pkgPath + strings.ToUpper(typeName[0:1]) + typeName[1:]

			if _, ok := p.resolvedImports[pkgPath]; !ok {
				p.resolvedImports[pkgPath] = struct{}{}
				p.schema.Imports = append(p.schema.Imports, &schema.Import{
					Path: pkgPath,
				})
			}
		}
		return p.parseNamedType(typeName, v.Underlying())

	case *types.Basic:
		return p.parseBasic(v)

	case *types.Struct:
		return p.parseStruct(typeName, v)

	case *types.Slice:
		return p.parseSlice(typeName, v)

	case *types.Interface:
		return p.parseInterface(typeName, v)

	case *types.Map:
		return p.parseMap(typeName, v)

	case *types.Pointer:
		varType, err = p.parseNamedType(typeName, v.Elem())
		if err != nil {
			return nil, errors.Wrap(err, "failed to dereference pointer")
		}
		return varType, nil

	default:
		return nil, errors.Errorf("unsupported argument type %T", typ)
	}
}

func (p *parser) parseBasic(typ *types.Basic) (*schema.VarType, error) {
	var varType schema.VarType
	if err := schema.ParseVarTypeExpr(p.schema, typ.Name(), &varType); err != nil {
		return nil, errors.Wrapf(err, "failed to parse basic type: %v", typ.Name())
	}

	return &varType, nil
}

func (p *parser) parseStruct(typeName string, structTyp *types.Struct) (*schema.VarType, error) {
	// typeName is for example "github.com/webrpc/webrpc/schema/VarType"
	// Split by separators & get the shortest possible unique prefixed type name (ie. schemaVarType).
	typeNameParts := strings.FieldsFunc(typeName, func(r rune) bool {
		return r == '.' || r == '/' || r == '-' || r == '_'
	})
	typeName = ""
	for i := len(typeNameParts) - 1; i >= 0; i-- {
		typeName = typeNameParts[i] + typeName
		if _, ok := p.parsedTypeNames[typeName]; !ok {
			p.parsedTypeNames[typeName] = struct{}{}
			break
		}
	}

	msg := &schema.Message{
		Name: schema.VarName(typeName),
		Type: schema.MessageType("struct"),
	}

	for i := 0; i < structTyp.NumFields(); i++ {
		field := structTyp.Field(i)
		if !field.Exported() {
			continue
		}

		tag := structTyp.Tag(i)
		if field.Embedded() || strings.Contains(tag, `json:",inline"`) {
			varType, err := p.parseNamedType("", field.Type())
			if err != nil {
				return nil, errors.Wrapf(err, "failed to parse var %v", field.Name())
			}

			if varType.Type == schema.T_Struct {
				for _, embeddedField := range varType.Struct.Message.Fields {
					msg.Fields = appendMessageFieldAndDeleteExisting(msg.Fields, embeddedField)
				}
			}
			continue
		}

		optional := false

		fieldName := field.Name()
		if strings.Contains(tag, `json:"`) {
			submatches := jsonTagRegex.FindStringSubmatch(tag)
			// Submatches from the jsonTagRegex:
			// [0]: json:"deleted_by,omitempty,string"
			// [1]: deleted_by
			// [2]: ,omitempty,string
			if len(submatches) != 3 {
				return nil, errors.Errorf("unexpected number of json struct tag submatches")
			}
			if submatches[1] == "-" { // suppressed field in JSON struct tag
				continue
			}
			if submatches[1] != "" { // field name defined in JSON struct tag
				fieldName = submatches[1]
			}
			optional = strings.Contains(submatches[2], ",omitempty")
			if strings.Contains(submatches[2], ",string") { // field type should be string in JSON
				msg.Fields = appendMessageFieldAndDeleteExisting(msg.Fields, &schema.MessageField{
					Name:     schema.VarName(fieldName),
					Type:     &schema.VarType{Type: schema.T_String},
					Optional: optional,
				})
				continue
			}
		}

		if _, ok := field.Type().Underlying().(*types.Pointer); ok {
			optional = true
		}

		// We need to come up with a name for anonymous struct fields. Example:
		// type Something struct {
		// 	 AnonymousField struct { // ==> this field doesn't have a type name since it's an anonymous struct, let's make it "SomethingAnonymousField"
		//     Name string
		//   }
		// }
		var anonymousStructTypeName string
		if _, ok := field.Type().Underlying().(*types.Struct); ok {
			anonymousStructTypeName = typeName + strings.ToTitle(fieldName[:1]) + fieldName[1:]
		}

		varType, err := p.parseNamedType(anonymousStructTypeName, field.Type())
		if err != nil {
			return nil, errors.Wrapf(err, "failed to parse var %v", field.Name())
		}

		msg.Fields = appendMessageFieldAndDeleteExisting(msg.Fields, &schema.MessageField{
			Name:     schema.VarName(fieldName),
			Type:     varType,
			Optional: optional,
		})
	}

	p.schema.Messages = append(p.schema.Messages, msg)

	return &schema.VarType{
		Type: schema.T_Struct,
		Struct: &schema.VarStructType{
			Name:    typeName,
			Message: msg,
		},
	}, nil
}

// Appends message field to the given slice, while also removing any previously defined field of the same name.
// This lets us overwrite embedded fields, exactly how Go does it behind the scenes in the JSON marshaller.
func appendMessageFieldAndDeleteExisting(slice []*schema.MessageField, newItem *schema.MessageField) []*schema.MessageField {
	// Let's try to find an existing item of the same name and delete it.
	for i, item := range slice {
		if item.Name == newItem.Name {
			// Delete item.
			copy(slice[i:], slice[i+1:])
			slice = slice[:len(slice)-1]
		}
	}
	// And then append the new item at the end of the slice.
	return append(slice, newItem)
}

func (p *parser) parseSlice(typeName string, sliceTyp *types.Slice) (*schema.VarType, error) {
	elem, err := p.parseNamedType(typeName, sliceTyp.Elem())
	if err != nil {
		return nil, errors.Wrap(err, "failed to parse slice type")
	}

	varType := &schema.VarType{
		Type: schema.T_List,
		List: &schema.VarListType{
			Elem: elem,
		},
	}

	return varType, nil
}

// Parse argument of type interface. We only allow context.Context and error.
func (p *parser) parseInterface(typeName string, iface *types.Interface) (*schema.VarType, error) {
	// TODO: A special case for error and context.Context.

	varType := &schema.VarType{
		Type: schema.T_Any,
	}

	return varType, nil
}

// Parse argument of type interface. We only allow context.Context and error.
func (p *parser) parseMap(typeName string, m *types.Map) (*schema.VarType, error) {
	key, err := p.parseNamedType(typeName, m.Key())
	if err != nil {
		return nil, errors.Wrap(err, "failed to parse map key type")
	}

	value, err := p.parseNamedType(typeName, m.Elem())
	if err != nil {
		return nil, errors.Wrap(err, "failed to parse map value type")
	}

	varType := &schema.VarType{
		Type: schema.T_Map,
		Map: &schema.VarMapType{
			Key:   key.Type,
			Value: value,
		},
	}

	return varType, nil
}
