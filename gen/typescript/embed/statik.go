// Code generated by statik. DO NOT EDIT.

// Package statik contains static assets.
package embed

import (
	"github.com/rakyll/statik/fs"
)

func init() {
	data := "PK\x03\x04\x14\x00\x08\x00\x00\x00\xd8\x9eFN\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0e\x00	\x00client.go.tmplUT\x05\x00\x01\x88;[\\{{define \"client\"}}\n{{if .Services}}\n  // Client\n\n  {{range .Services}}\n  const {{.Name | constPathPrefix}} = \"/rpc/{{.Name}}/\"\n  {{end}}\n\n  {{range .Services}}\n    {{ $serviceName := .Name | clientServiceName}}\n    type {{$serviceName}} struct {\n      client HTTPClient\n      urls   [{{.Methods | countMethods}}]string\n    }\n\n    func {{.Name | newClientServiceName }}(addr string, client HTTPClient) {{.Name}} {\n      prefix := urlBase(addr) + ExampleServicePathPrefix\n      urls := [{{.Methods | countMethods}}]string{\n        {{range .Methods}}\n        prefix + \"{{.Name}}\",\n        {{end}}\n      }\n      return &exampleServiceClient{\n        client: client,\n        urls:   urls,\n      }\n    }\n\n    {{range $i, $method := .Methods}}\n      func (c *{{$serviceName}}) {{.Name}}({{.Inputs | methodInputs}}) ({{.Outputs | methodOutputs }}) {\n        {{range .Outputs}}\n          out := new()\n        {{end}}\n        {{if .Inputs | len}}\n        err := doJSONRequest(ctx, c.client, c.urls[{{$i}}], req, out)\n        {{else}}\n        err := doJSONRequest(ctx, c.client, c.urls[{{$i}}], nil, out)\n        {{end}}\n        if err != nil {\n          return nil, err\n        }\n        return out, nil\n      }\n    {{end}}\n  {{end}}\n{{end}}\n{{end}}\nPK\x07\x08\xbb\xba}u\xd9\x04\x00\x00\xd9\x04\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x001\x9fFN\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0f\x00	\x00helpers.go.tmplUT\x05\x00\x01.<[\\{{define \"helpers\"}}\n{{end}}\nPK\x07\x08\x92!\x1d^\x1d\x00\x00\x00\x1d\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00*\x9fFN\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x11\x00	\x00proto.gen.go.tmplUT\x05\x00\x01!<[\\{{define \"proto\"}}\n\n{{template \"types\" .}}\n\n{{template \"client\" .}}\n\n{{template \"server\" .}}\n\n{{template \"helpers\" .}}\n\n{{end}}\nPK\x07\x08o\xf9\x16T\x80\x00\x00\x00\x80\x00\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00\xe8\x9eFN\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0e\x00	\x00server.go.tmplUT\x05\x00\x01\xa5;[\\{{define \"server\"}}\n{{if .Services}}\n  // Server\n  {{range .Services}}\n    {{$name := .Name}}\n    {{$serviceName := .Name | serverServiceName}}\n\n    type {{$serviceName}} struct {\n      {{.Name}}\n    }\n\n    func {{ .Name | newServerServiceName }}(svc {{.Name}}) WebRPCServer {\n      return &{{$serviceName}}{\n        {{.Name}}: svc,\n      }\n    }\n\n\n    func (s *{{$serviceName}}) WebRPCVersion() string {\n      return \"v0.0.1\"\n    }\n\n    func (s *{{$serviceName}}) ServiceVersion() string {\n      return \"v0.1.0\"\n    }\n\n    func (s *exampleServiceServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n      ctx := r.Context()\n      ctx = webrpc.WithResponseWriter(ctx, w)\n      ctx = webrpc.WithServiceName(ctx, \"ExampleService\")\n\n      if r.Method != \"POST\" {\n        err := webrpc.Errorf(webrpc.ErrBadRoute, \"unsupported method %q (only POST is allowed)\", r.Method)\n        writeJSONError(ctx, w, r, err)\n        return\n      }\n\n      switch r.URL.Path {\n      {{range .Methods}}\n      case \"/rpc/{{$name}}/{{.Name}}\":\n        s.{{.Name | serviceMethodName}}(ctx, w, r)\n        return\n      {{end}}\n      default:\n        err := webrpc.Errorf(webrpc.ErrBadRoute, \"no handler for path %q\", r.URL.Path)\n        writeJSONError(ctx, w, r, err)\n        return\n      }\n    }\n\n    {{range .Methods}}\n      func (s *{{$serviceName}}) {{.Name | serviceMethodName}}(ctx context.Context, w http.ResponseWriter, r *http.Request) {\n        header := r.Header.Get(\"Content-Type\")\n        i := strings.Index(header, \";\")\n        if i == -1 {\n          i = len(header)\n        }\n\n        switch strings.TrimSpace(strings.ToLower(header[:i])) {\n        case \"application/json\":\n          s.{{ .Name | serviceMethodJSONName }}(ctx, w, r)\n        default:\n          err := webrpc.Errorf(webrpc.ErrBadRoute, \"unexpected Content-Type: %q\", r.Header.Get(\"Content-Type\"))\n          writeJSONError(ctx, w, r, err)\n        }\n      }\n\n      func (s *{{$serviceName}}) {{.Name | serviceMethodJSONName}}(ctx context.Context, w http.ResponseWriter, r *http.Request) {\n        var err error\n        ctx = webrpc.WithMethodName(ctx, \"{{.Name}}\")\n\n        {{if .Inputs|len}}\n\n        {{range .Inputs}}\n        reqContent := new(TODO)\n        {{end}}\n\n        reqBody, err := ioutil.ReadAll(r.Body)\n        if err != nil {\n          err = webrpc.WrapError(webrpc.ErrInternal, err, \"failed to read request data\")\n          writeJSONError(ctx, w, r, err)\n          return\n        }\n        defer r.Body.Close()\n\n        err = json.Unmarshal(reqBody, reqContent)\n        if err != nil {\n          err = webrpc.WrapError(webrpc.ErrInternal, err, \"failed to unmarshal request data\")\n          writeJSONError(ctx, w, r, err)\n          return\n        }\n        {{end}}\n\n        // Call service method\n        {{range .Outputs}}\n        var respContent *TODO\n        {{end}}\n        func() {\n          defer func() {\n            // In case of a panic, serve a 500 error and then panic.\n            if rr := recover(); rr != nil {\n              writeJSONError(ctx, w, r, webrpc.ErrorInternal(\"internal service panic\"))\n              panic(rr)\n            }\n          }()\n          {{if .Inputs|len}}\n          respContent, err = s.{{$name}}.{{.Name}}(ctx, reqContent)\n          {{else}}\n          respContent, err = s.{{$name}}.{{.Name}}(ctx)\n          {{end}}\n        }()\n\n        if err != nil {\n          writeJSONError(ctx, w, r, err)\n          return\n        }\n\n        respBody, err := json.Marshal(respContent)\n        if err != nil {\n          err = webrpc.WrapError(webrpc.ErrInternal, err, \"failed to marshal json response\")\n          writeJSONError(ctx, w, r, err)\n          return\n        }\n\n        w.Header().Set(\"Content-Type\", \"application/json\")\n        w.WriteHeader(http.StatusOK)\n\n        if n, err := w.Write(respBody); err != nil {\n          _ = n\n          _ = err\n          // TODO: failing silently for now..\n          // msg := fmt.Sprintf(\"failed to write response, %d of %d bytes written: %s\", n, len(respBytes), err.Error())\n        }\n      }\n    {{end}}\n  {{end}}\n{{end}}\n{{end}}\nPK\x07\x08vS\xcf\x86\xec\x0f\x00\x00\xec\x0f\x00\x00PK\x03\x04\x14\x00\x08\x00\x00\x00U\x06GN\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0d\x00	\x00types.go.tmplUT\x05\x00\x01\xe2\x80[\\{{define \"types\"}}\n{{if .Messages}}\n  {{range .Messages}}\n    {{if .Type | isEnum}}\n      {{$enumName := .Name}}\n      {{range .Fields}}\n        // {{$enumName}}_{{.Name}} = {{.Type}} {{.Value}}\n      {{end}}\n    {{end}}\n    {{if .Type | isStruct  }}\n      export interface {{.Name | interfaceName}} {\n        {{range .Fields}}\n          {{.Name | exportedField}}{{.Optional | optional}}: {{.Type | fieldType}}\n        {{end}}\n      }\n\n      export class {{.Name}} implements {{.Name | interfaceName}} {\n        private _data: {{.Name | interfaceName}}\n        constructor(_data?: {{.Name | interfaceName}}) {\n          this._data = {}\n          if (_data) {\n            {{range .Fields}}\n              this._data['{{.Name | exportedField}}'] = _data['{{.Name | exportedField}}']\n            {{end}}\n          }\n        }\n        public toJSON(): object {\n          returns this._data\n        }\n      }\n    {{end}}\n  {{end}}\n{{end}}\n{{if .Services}}\n  {{range .Services}}\n    export interface {{.Name | serviceInterfaceName}} {\n      {{range .Methods}}\n        {{.Name}}: ({{.Inputs | methodInputs}}) {{.Outputs | methodOutputs}}\n      {{end}}\n    }\n\n    export class {{.Name}} implements {{.Name | serviceInterfaceName}} {\n      {{range .Methods}}\n        {{.Name}}({{.Inputs | methodInputs}}) ({{.Outputs | methodOutputs}})\n      {{end}}\n    }\n  {{end}}\n  var Services = map[string][]string{\n    {{range .Services}}\n      \"{{.Name}}\": {\n        {{range .Methods}}\n          \"{{.Name}}\",\n        {{end}}\n      },\n    {{end}}\n  }\n{{end}}\n{{end}}\nPK\x07\x08\xe2\x1a\xd4\x19\n\x06\x00\x00\n\x06\x00\x00PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\xd8\x9eFN\xbb\xba}u\xd9\x04\x00\x00\xd9\x04\x00\x00\x0e\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb4\x81\x00\x00\x00\x00client.go.tmplUT\x05\x00\x01\x88;[\\PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x001\x9fFN\x92!\x1d^\x1d\x00\x00\x00\x1d\x00\x00\x00\x0f\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb4\x81\x1e\x05\x00\x00helpers.go.tmplUT\x05\x00\x01.<[\\PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00*\x9fFNo\xf9\x16T\x80\x00\x00\x00\x80\x00\x00\x00\x11\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb4\x81\x81\x05\x00\x00proto.gen.go.tmplUT\x05\x00\x01!<[\\PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00\xe8\x9eFNvS\xcf\x86\xec\x0f\x00\x00\xec\x0f\x00\x00\x0e\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb4\x81I\x06\x00\x00server.go.tmplUT\x05\x00\x01\xa5;[\\PK\x01\x02\x14\x03\x14\x00\x08\x00\x00\x00U\x06GN\xe2\x1a\xd4\x19\n\x06\x00\x00\n\x06\x00\x00\x0d\x00	\x00\x00\x00\x00\x00\x00\x00\x00\x00\xb4\x81z\x16\x00\x00types.go.tmplUT\x05\x00\x01\xe2\x80[\\PK\x05\x06\x00\x00\x00\x00\x05\x00\x05\x00\\\x01\x00\x00\xc8\x1c\x00\x00\x00\x00"
	fs.Register(data)
}
